1，浏览器解析html源码，然后创建一个 DOM树。
在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。
DOM树的根节点就是 documentElement，对应的是html标签。

2，浏览器解析CSS代码，计算出最终的样式数据。
对CSS代码中非法的语法她会直接忽略掉。
解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置，用户设置，外链样式，内联样式，html中的style。

3，构建出DOM树，并且计算出样式数据后，下一步就是构建一个 渲染树（rendering tree）。
渲染树和DOM树有点像，但是是有区别的。DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。
而且一大段文本中的每一个行在渲染树中都是独立的一个节点。
渲染树中的每一个节点都存储有对应的css属性。

4，一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

具体渲染过程:
1.解析html生成DOM树
2.计算css样式, 生成渲染树
	2.1 为每个节点生成图形和位置(重排)
	2.2 将每个节点绘制到相应图层位图中(重绘)
	2.3 图层作为文理上传到GPU
	2.4 重组多个图层到页面上生成最重屏幕图像

引发重排:
	修改节点尺寸, 定位, 浮动属性, 内部文字结构
引发重绘:
	没有改变尺寸, 只改变背景色, 颜色


优化:
尽量不要触发页面重排和重绘, 仅触发图层重组最好:
* opacity
* translate
* rotate
* scale
1.将多次改变样式属性的操作合并成一次操作(修改类名)
2.不要频繁获取计算后的样式。如果你需要使用计算后的样式，最好暂存起来而不是直接从DOM上读取。
3.将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。
4.在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的html片段，再一次性添加到文档中去，而不是循环添加每一行。
5.由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。


JS动画:
优点: 灵活, 好控制
缺点: 容易阻塞, 丢帧

CSS动画:
优点: 优化好
缺点: 不灵活(视差滚动效果只有JS能很好的实现)