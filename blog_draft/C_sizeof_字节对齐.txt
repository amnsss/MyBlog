各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。

准则:

其实字节对齐的细节和具体编译器实现相关，但一般而言，满足三个准则：

　　1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；

　　2) 结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；例如上面第二个结构体变量的地址空间。

　　3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。例如上面第一个结构体变量。

注意：
int a[50];  //sizeof(a)=4*50=200; 求数组所占的空间大小
int *a=new int[50];// sizeof(a)=4; a为一个指针

参数为结构或类。Sizeof应用在类和结构的处理情况是相同的。但有两点需要注意，第一、结构或者类中的静态成员不对结构或者类的大小产生影响，因为静态变量的存储位置与结构或者类的实例地址无关。第二、没有成员变量的结构或类的大小为1，因为必须保证结构或类的每一个实例在内存中都有唯一的地址。
Class Test{int a;static double c};//sizeof(Test)=4
Class test1{ };//sizeof(test1)=1

int func(char s[5]);
   {
     cout<<sizeof(s);//这里将输出4，本来s为一个数组，但由于做为函
                    //数的参数在传递的时候系统处理为一个指针，所
                    //以sizeof(s)实际上为求指针的大小。
     return 1;
}
sizeof(func(“1234”))=4//因为func的返回类型为int，所以相当于
                    //求sizeof(int).

gcc对结构的存储的特殊处理确实提高CPU存储变量的速度，但是有时候也带来了一些麻烦，我们也可以屏蔽掉变量默认的对齐方式，自己设定变量的对齐方式。gcc中提供了#pragma pack(n)来设定变量以n字节对齐方式。n字节对齐就是说变量存放的起始地址的偏移量有两种情况：第一、如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式，第二、如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式。结构的总大小也有个约束条件，分下面两种情况：如果n大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；

有待了解：
结构对齐是基础知识,这种问题只有一个目的,就是看你对语言细节的了解程度.
在网络通讯,多个模块交互的应用中这种东西是很常见.这一类的东西还有像__stdcall,__cdecl,volatile,mutable这些东西.平常学习中很难遇到,但实际工作中却会用.__stdcall, __cdecl参数传入的顺序从右到左，不同是前者修改的函数的参数stack从被调用者清除，而后者由调用者清除。所以后者编译出来的二进制代码比较前者大。volatile定义的变量防止被编译器优化掉。
mutable定义的变量一般都非静态或者非常量类成员。它允许常量类成员对其赋值。

引用：http://blog.csdn.net/ajioy/article/details/8127209